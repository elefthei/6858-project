Current PAL Implementation
======================

 + User logins (through SSH, using public-key) go to an anonymous user 
 	  with effectively no permissions. This user may be in a chroot.
 - The sshd login is intercepted and instead a new user is created 
      on the fly. By prefixing logins with the on-login and setup-jail 
      scripts in incperm/bin, new users are allocated names and their 
      directories setup. User ID's are not reused, and are instead 
      allocated using a counter that is updated using an atomic
      rename (incperm/var/uid).


 + A setuid binary allows a user to spawn a shell with added
    permissions, after doing the necessary authentication. Permissions will
    have been allocated by the administrator, and are password protected.
 - The binary sets the uid and gid for the process correctly before 
      spawning a new shell, and the source code is /permd/perm.c. 
      After running `make` inside of permd, the setuid binary is found 
      in /incperm/skel.


 + A root daemon listens to authentication requests (effectively,
    logins), and reports whether or not authentication succeeded.
    This is what the aforementioned setuid binary uses.
 - The authentication code is found in /pald and exposes an API for
      the setuid binary.


 + Some administrator scripts exist to add groups/permissions.
 - The make-perm, protect-binary, and protect-directory scripts
      in incperm/bin allow for administrators to setup permissions
      on the server. Permissions are set by making groups with a paired
      user, and the password for the permissions are the password for
      the associated user account.
      
Future Plans
------------

 + Have the root daemon allocate sockets on priviledged ports and then pass
   them to requesting processes, while checking their capabilities.

 + Have an application-level API, for doing similar splitting within
      an application.

 + Possibly add a kernel module to be able to change the permissions
      of a program after it is run.
